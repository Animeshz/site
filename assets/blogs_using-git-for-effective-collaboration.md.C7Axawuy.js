import{_ as i}from"./chunks/cover.IFS8Cj5_.js";import{_ as d,c as h,a as r,b as m,d as g,w as p,e as f,r as n,o as s,f as u,g as b}from"./chunks/framework.BIeOwSkr.js";const y="/site/assets/commits.CciCZvyd.png",w="/site/assets/branch-time-independence.Dq0cn69D.png",k="/site/assets/merge-basic.Bem6nTSI.png",v="/site/assets/merge-with-rebase.D9xMCZ8Q.png",x="/site/assets/rebase-example.vhjLWVea.gif",_="/site/assets/reflog-example.BWCti4jz.gif",D=JSON.parse('{"title":"Using git for effective collaboration","description":"Understanding branch, refs and rebase.","frontmatter":{"title":"Using git for effective collaboration","description":"Understanding branch, refs and rebase.","created":"2023-06-28 01:10 AM","image":"/blogs/git/cover.jpg","tags":["git","version-control"]},"headers":[],"relativePath":"blogs/using-git-for-effective-collaboration.md","filePath":"blogs/using-git-for-effective-collaboration.md","lastUpdated":1728635740000}'),q={name:"blogs/using-git-for-effective-collaboration.md"};function I(t,e,A,T,P,C){const c=n("BlogMetadata"),l=n("ClientOnly");return s(),h("div",null,[e[0]||(e[0]=r("h1",{id:"using-git-for-effective-collaboration",tabindex:"-1"},[m("Using git for effective collaboration "),r("a",{class:"header-anchor",href:"#using-git-for-effective-collaboration","aria-label":'Permalink to "Using git for effective collaboration"'},"​")],-1)),g(l,null,{default:p(()=>{var o,a;return[(((o=t.$frontmatter)==null?void 0:o.aside)??!0)&&(((a=t.$frontmatter)==null?void 0:a.showArticleMetadata)??!0)?(s(),u(c,{key:0,frontmatter:t.$frontmatter,wordCount:1283},null,8,["frontmatter"])):b("",!0)]}),_:1}),e[1]||(e[1]=f('<p>Most important part of this blog post is <a href="#fixing-mistakes">fixing your mistakes</a> section, the whole blog post slowly builds up to there. Unleashing git to leverage to your advantage and overcoming any fear to use it by learning to fix anything that could ever possibly go wrong.</p><p><img src="'+i+'" alt="Cover Image"></p><h2 id="a-quick-recap" tabindex="-1">A quick recap <a class="header-anchor" href="#a-quick-recap" aria-label="Permalink to &quot;A quick recap&quot;">​</a></h2><p>This is everything you&#39;d need to know to get started with the blog post.</p><ol><li><code>git add .</code> | <code>git add -u</code> | <code>git add &lt;file|folder&gt;</code> doesn&#39;t <em>inherently do anything</em>. <ul><li><code>.</code> refers to everything (equivalent to <code>.* *</code>).</li><li><code>-u</code> adds files which are modified, but not any new (untracked) files.</li></ul></li><li><code>git commit -m &#39;msg&#39;</code> makes a checkpoint from the items added using <code>git add</code>. <img src="'+y+'" alt="commits" style="display:block;margin:0 auto;"></li><li>git push - syncs remote with local state. <ul><li>Checkout <a href="https://animeshz.github.io/site/blogs/git.html#installation" target="_blank" rel="noreferrer">my last article on git</a> for setting up accounts on git and git remotes for first time if you&#39;re unable to push.</li></ul></li></ol><h2 id="branch" tabindex="-1">Branch <a class="header-anchor" href="#branch" aria-label="Permalink to &quot;Branch&quot;">​</a></h2><p>Branches allows independence of commits.</p><p><img src="'+w+'" alt="Branch Time Independence"></p><p>That is, <code>main</code> can progress without worrying about <code>dev</code>, and <code>dev</code> can progress without any dependence on changes to <code>main</code>.</p><h3 id="creating-and-checking-branches" tabindex="-1">Creating and Checking Branches <a class="header-anchor" href="#creating-and-checking-branches" aria-label="Permalink to &quot;Creating and Checking Branches&quot;">​</a></h3><ul><li><code>git checkout -b dev</code> creates a new branch <code>dev</code> and checkout that branch.</li><li><code>git checkout main</code> checkout (existent) branch <code>main</code>.</li><li><code>git branch</code> to see all branches and see which one is checked out.</li><li><code>git branch -a</code> --&#39;&#39;-- including remote branches.</li></ul><p>After changing the branch, add / commit / push and everything else works the same.</p><p><sub style="line-height:0.5rem;"><b style="font-family:&#39;Inter var&#39;, Inter;">Note:</b> <code>git switch</code> behaves quite similar to <code>git checkout</code>, but it lacks some of the features, which we&#39;ll talk about in the main section of this blog post <a href="#fixing-mistakes">fixing your mistakes</a>.</sub></p><p><sub>I&#39;ll recommend sticking with <code>git checkout</code> for now.</sub></p><h2 id="merging-and-rebasing" tabindex="-1">Merging and Rebasing <a class="header-anchor" href="#merging-and-rebasing" aria-label="Permalink to &quot;Merging and Rebasing&quot;">​</a></h2><p>The prime purpose of branching is to maximize parallel work, by effectively branching out an independent timeline, making sure that the <code>main</code> branch is safe from any experimental changes.</p><p>After the feature&#39;s been completely implemented, we may want to incorporate the changes into the <code>main</code> branch however, and that process is known as <code>merge</code> in git.</p><h3 id="to-merge" tabindex="-1">To merge <a class="header-anchor" href="#to-merge" aria-label="Permalink to &quot;To merge&quot;">​</a></h3><p>We can either</p><ol><li><code>git checkout main &amp;&amp; git merge dev</code></li><li>Send a PR (or MR in gitlab) from <code>dev</code> to <code>main</code> (2nd person), and accept it.</li></ol><p>Commands are quite easy, but the situtation may not be.</p><div class="info custom-block"><p class="custom-block-title">TIP</p><p><code>git pull [remote branch]</code> is a shorthand for<br><code>git fetch [remote branch] &amp;&amp; git merge remote/branch</code></p></div><h3 id="situations-on-merge" tabindex="-1">Situations on merge <a class="header-anchor" href="#situations-on-merge" aria-label="Permalink to &quot;Situations on merge&quot;">​</a></h3><p><img src="'+k+'" alt="Merge Basic"></p><p><b style="font-family:&#39;Inter var&#39;, Inter;">Fast-Forward:</b> The best case scenario is when <code>main</code> hasn&#39;t moved yet, in that case merge simply fast-forwards the <code>main</code> pointer (we call it ref) to match up with <code>dev</code>&#39;s ref.</p><p>In rest of the cases, we get atleast 1 redundant commit.</p><p><b style="font-family:&#39;Inter var&#39;, Inter;">Merge with conflict:</b> is a special case, where same lines of same file&#39;s been edited by both the branches. And since we&#39;re considering main is stable, we&#39;d say some commit on <code>dev</code> branch has conflict with tip of the <code>main</code> rather than vice versa regardless which branch committed first in the time.</p><p>For merging with conflicts, considering main is stable branch, we&#39;d want to merge <code>main</code> into <code>dev</code> first and resolve conflicts then merge <code>dev</code> into <code>main</code>. As in PRs you don&#39;t ask the repository owner to resolve conflicts rather you the holder of PR, the holder of dev branch, resolve conflicts on your branch.</p><h3 id="rebase" tabindex="-1">Rebase <a class="header-anchor" href="#rebase" aria-label="Permalink to &quot;Rebase&quot;">​</a></h3><p>Problem with non fast-forward merge is that the git history can get really really messy.</p><p>In the later stage you&#39;ll come to know about <code>git bisect</code>, a binary-search for finding bugs in the history, if history is linear -&gt; well-n-good, but what if there&#39;s too many quadrilateral in there like in the above diagram? Well, you guessed it right, it&#39;ll hit you hard at that time.</p><p>It also creates a problem when you want to reorder the commits (yes you can! we&#39;ll be discussing it in <a href="#fixing-mistakes">fixing your mistakes</a>), the multi-parent commits will be really really disgusting.</p><p><code>git rebase</code> comes to rescue here, <em>an intermediatery step</em> that&#39;ll prevent formation of those redundant commits on merge. Precisely by re-basing the parent of the exclusive commits to tip of main.</p><p>To do this, you&#39;d have to <code>git checkout dev &amp;&amp; git rebase main</code> before the merge step.</p><p><img src="'+v+'" alt="Merge with Rebase"></p><p>How beautiful!</p><p>The merge (2nd step) has just became fast-forward.</p><p>The history becomes linear!</p><div class="info custom-block"><p class="custom-block-title">TIP</p><p>Its always better to rebase before merge.</p><p>There&#39;s no harm, only the timestamp on commit changes.</p><p><code>git pull --rebase</code> is always better than <code>git pull</code> if you care about a good git history.</p></div><h2 id="fixing-mistakes" tabindex="-1">Fixing mistakes <a class="header-anchor" href="#fixing-mistakes" aria-label="Permalink to &quot;Fixing mistakes&quot;">​</a></h2><p>Yeah, The main topic of the blog post!</p><p>Before starting I wanna talk about refs.</p><h3 id="refs" tabindex="-1">Refs <a class="header-anchor" href="#refs" aria-label="Permalink to &quot;Refs&quot;">​</a></h3><p>Refs can be:</p><ul><li>A commit hash (e.g. <code>c80eb9</code>, that you see typically on <code>git log</code>).</li><li>A branch name.</li><li>A tag name.</li><li>Special variable <code>HEAD</code> (pointing to checked branch) or its parents referred by <code>HEAD~n</code>.</li></ul><p><img src="'+i+'" alt="Refs"></p><p>All of these are refs.</p><p><code>git checkout</code> is the command that inherently moves the <code>HEAD</code> ref.</p><p>The <code>HEAD</code> is responsible for the directory structure you see. Its the internal detail of changing branches. <code>HEAD~1</code> refers to the 2nd last commit on current branch (current HEAD&#39;s parent), and so on.</p><p><b style="font-family:&#39;Inter var&#39;, Inter;">Tag:</b> are similar to branch, but <code>git commit</code> doesn&#39;t increment the tag pointer unlike branch. Tag always point to a constant commit. Its automatically created for creating releases (for versions).</p><p>A <code>git checkout</code> on anything other than a branch name, moves repository in a <a href="https://www.git-tower.com/learn/git/faq/detached-head-when-checkout-commit" target="_blank" rel="noreferrer">Detached HEAD state</a>, see the linked-reference, I don&#39;t want to talk about it much here.</p><h3 id="interactive-rebase-the-real-fix" tabindex="-1">Interactive Rebase (the real fix) <a class="header-anchor" href="#interactive-rebase-the-real-fix" aria-label="Permalink to &quot;Interactive Rebase (the real fix)&quot;">​</a></h3><p>This is where you fix your mistakes!</p><p>Anything from</p><ul><li>Wrong message in commits.</li><li>Missed to incorporate some changes on some commits.</li><li>Committed by mistake and new commits have been added over it.</li><li>Reordering of commits.</li><li>Wrong author in commit.</li></ul><p>all of these can be fixed, by one single command: <code>git rebase -i HEAD~n</code> (or <code>git rebase -i --root</code>).</p><p>This command, is the ultimate answer to everything!</p><p>This command will open a file something like this (on editor set by environmental variable <code>$EDITOR</code>):</p><p><img src="'+x+'" alt="Rebase Example"></p><p>This is ultimate place you can do whatever you want!</p><p>Move the line to reorder the commit, as if one commit that has been added later in the time appears to came first.</p><p>Delete the line to make a commit disappear from the course of history.</p><p>put <code>r</code> or <code>reword</code> in front of a line to rename the commit (after saving and exiting this file).</p><p>put <code>f</code> or <code>fixup</code> or <code>s</code> or <code>squash</code> in front of line to squash commit in this line to just above commit - 2 commits into 1 commit (if you forget some changes to commit add a new commit and perform this!). <code>squash</code> let&#39;s you change the commit message, whereas <code>fixup</code> doesn&#39;t.</p><p>put <code>e</code> or <code>edit</code> in front of line to stop rebase on that that commit, let you work on that point in history, run <code>git add .</code> and <code>git rebase --continue</code> afterwards, to edit commit in between the history wow!</p><p>these are the major controls, you can also explore <code>exec</code> and <code>break</code> if you like!</p><h2 id="fixing-mistakes-over-fixing-mistakes" tabindex="-1">Fixing mistakes over fixing mistakes <a class="header-anchor" href="#fixing-mistakes-over-fixing-mistakes" aria-label="Permalink to &quot;Fixing mistakes over fixing mistakes&quot;">​</a></h2><p><code>git rebase</code> is a dangerous operation, likewise <code>git checkout</code>, as both of them moves <code>HEAD</code> pointer (or ref, whatever you wanna call it), which is directly connected to the state of repository, its populates your folder with bunch of files you expect in the project.</p><p>Because of this, with accidental rebase option, you may overwrite the branch &amp; loose the previous state of repository.</p><p>This is where <code>git reflog show</code> comes in!</p><p>It records every moment when <code>HEAD</code> has moved, i.e. there&#39;s always a record where HEAD pointed to before you performed <em>any potentially dangerous operation</em>, so you&#39;re backed up with <b style="font-family:&#39;Inter var&#39;, Inter;">cold water immersion suit</b> so you can never fall in the depth of ocean.</p><p>Just do a <code>git reflog show</code> and <code>git reset --hard 76e2269</code> with the hash you see on the reflog command to reset the repository back to where it was.</p><p><img src="'+_+'" alt="Reflog Example"></p><h2 id="further-reading" tabindex="-1">Further reading <a class="header-anchor" href="#further-reading" aria-label="Permalink to &quot;Further reading&quot;">​</a></h2><p>Git has a lot more, the <code>bisect</code> I mentioned earlier, and more.</p><p>See</p><ul><li><a href="https://animeshz.github.io/site/blogs/git.html#other-useful-stuffs" target="_blank" rel="noreferrer">Useful stuffs</a> from my last blog post on git (highly recommend).</li><li><a href="https://towardsdatascience.com/understanding-the-fundamentals-of-git-25b5b7ded3c4" target="_blank" rel="noreferrer">Internals - fundamentals of git</a> (optional read - i.e. to say understanding it really does any good is subjective - maybe hard and won&#39;t be any useful for most people).</li></ul><p>If you&#39;ve come to this point of the post, thanks alot for your attention! You&#39;re welcome to visit around the site, I put everything I know here, if not today, will surely on someday.</p><p>Backlinks:</p><ul><li><a href="https://www.reddit.com/r/git/comments/14kyky1/using_git_for_effective_collaboration" target="_blank" rel="noreferrer">r/git</a> | <a href="https://www.reddit.com/r/github/comments/14kyl9r/using_git_for_effective_collaboration" target="_blank" rel="noreferrer">r/github</a></li><li><a href="https://www.linkedin.com/posts/animeshz_using-git-for-effective-collaboration-activity-7079547033325322240-4Gj3" target="_blank" rel="noreferrer">Linkedin</a></li></ul>',80))])}const E=d(q,[["render",I]]);export{D as __pageData,E as default};
