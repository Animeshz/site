import{_ as n,c as a,a as e,b as t,t as o,d as r,o as l}from"./app.43844968.js";const D=JSON.parse(`{"title":"Working with Binaries","description":"","frontmatter":{"title":"Working with Binaries","slug":"working-with-binaries"},"headers":[{"level":2,"title":"Background","slug":"background","link":"#background","children":[]},{"level":2,"title":"Running binaries in seperate root (even linked against musl libc in glibc environment)","slug":"running-binaries-in-seperate-root-even-linked-against-musl-libc-in-glibc-environment","link":"#running-binaries-in-seperate-root-even-linked-against-musl-libc-in-glibc-environment","children":[{"level":3,"title":"Abstract","slug":"abstract","link":"#abstract","children":[]},{"level":3,"title":"Let's go","slug":"let-s-go","link":"#let-s-go","children":[]}]}],"relativePath":"blogs/working-with-binaries.md"}`),i={name:"blogs/working-with-binaries.md"},p={id:"frontmatter-title",tabindex:"-1"},c=e("a",{class:"header-anchor",href:"#frontmatter-title","aria-hidden":"true"},"#",-1),d=r(`<h2 id="background" tabindex="-1">Background <a class="header-anchor" href="#background" aria-hidden="true">#</a></h2><p>I really struggled first when I was introduced to cross-compilation in C. It was when I tried to compile a C as a library (.so/.dll) for exposing a few functionality to JVM/NodeJS in my keyboard-mouse-kt project.</p><p>It was really troublesome to see that cross-compilers don&#39;t exist in alpine repositories and only a few selected ones are on debian. So I literally made my own docker image with my own build of <a href="https://github.com/Animeshz/mainstream-cross-compilers" target="_blank" rel="noreferrer">cross-compilers</a>. It was fun! And I still refer to them.</p><p>I&#39;ve been tinkering with binaries ever since then, like for example <a href="https://www.youtube.com/watch?v=EJtUW2AklVs&amp;list=PLI_rLWXMqpSkAYfar0HRA7lykydwmRY_2&amp;index=2" target="_blank" rel="noreferrer">setuid to gain superuser without sudo</a> and stuffs like that.</p><p>And today I found something very interesting, and its not on exploitation, but could be something very useful for something like multiple-version package installation by putting them into directory of their own, see below.</p><h2 id="running-binaries-in-seperate-root-even-linked-against-musl-libc-in-glibc-environment" tabindex="-1">Running binaries in seperate root (even linked against musl libc in glibc environment) <a class="header-anchor" href="#running-binaries-in-seperate-root-even-linked-against-musl-libc-in-glibc-environment" aria-hidden="true">#</a></h2><h3 id="abstract" tabindex="-1">Abstract <a class="header-anchor" href="#abstract" aria-hidden="true">#</a></h3><p>For new ones, libc is something that exposes functionalities like <code>printf</code> and similar so that you can interface with the world outside the very basic primitives processor defines like add or subtract.</p><p>There are many libc implementations, in Windows there&#39;s one standard <code>msvcrt.dll</code> (generally referred to as MSVC), in Linux there are two implementations: glibc (33MB, from GNU) and musl (4MB, by Rich Felker). The other one is trying to replace the former which has legacy garbage.</p><blockquote><p>FunFact: MinGW (even though uses gnu-gcc compilers) links with msvcrt and not glibc.</p></blockquote><h3 id="let-s-go" tabindex="-1">Let&#39;s go <a class="header-anchor" href="#let-s-go" aria-hidden="true">#</a></h3><p>I&#39;ve recently tried to unify multiple package managers and had to deal with many edge-cases while trying to reduce the system modification while installation yet giving binary/fonts/config access to the user, there could&#39;ve been many ways, symlinking, bind-mounts, overlayfs/aufs, fusefs like the one bedrock-linux do, etc. Even though any of them would&#39;ve worked, there was one major problem, the packages from big repositories are made for libraries present in <code>/usr/lib</code> and against system libc/interpreter.</p><p>Once you have prepared a sepearte root (e.g. of musl based linux) say in <code>/another_root</code> (explained in <a href="/site/notes/linux/linux-random-stuffs.html#process-monitoring-usr-bin-time">Linux/RandomStuffs</a>), the way we execute binaries in seperate root is either by <code>chroot</code>ing, or by:</p><div class="language-bash line-numbers-mode"><button class="copy"></button><span class="lang">bash</span><pre><code><span class="line"><span style="color:#A6ACCD;">LD_LIBRARY_PATH=/another_root/usr/lib /another_root/usr/lib/ld-musl-x86_64.so.1 /another_root/usr/bin/</span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;">binary</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>Bla bla bla, too much to modify.</p><p>Fortunately there&#39;s <a href="https://github.com/NixOS/patchelf" target="_blank" rel="noreferrer">NixOS/patchelf</a> available which exactly modifies binaries search path and interpreter. So the following will replace all absolute path symlink, the libc interpreter, and the library search path for that particular executable.</p><div class="language-bash line-numbers-mode"><button class="copy"></button><span class="lang">bash</span><pre><code><span class="line"><span style="color:#A6ACCD;">fd -tl </span><span style="color:#82AAFF;">.</span><span style="color:#A6ACCD;"> /another_root </span><span style="color:#89DDFF;">|</span><span style="color:#A6ACCD;"> xargs -I{} sudo sh -c </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">lnk=$(readlink {} | grep &quot;^/&quot;) &amp;&amp; ln -sf /another_root$lnk {}</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">fd -tx </span><span style="color:#82AAFF;">.</span><span style="color:#A6ACCD;"> /another_root/usr/bin </span><span style="color:#89DDFF;">|</span><span style="color:#A6ACCD;"> xargs -I{} sudo sh -c </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">file {} | grep ELF &gt; /dev/null &amp;&amp; echo {}</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">|</span><span style="color:#A6ACCD;"> xargs -I{} sudo -E sh -c </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">ip=$(patchelf --print-interpreter {} 2&gt;/dev/null) &amp;&amp; patchelf --set-interpreter /another_root$ip {}</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">fd -tx </span><span style="color:#82AAFF;">.</span><span style="color:#A6ACCD;"> /another_root/usr/bin </span><span style="color:#89DDFF;">|</span><span style="color:#A6ACCD;"> xargs -I{} sudo sh -c </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">file {} | grep ELF &gt; /dev/null &amp;&amp; echo {}</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">|</span><span style="color:#A6ACCD;"> xargs -I{} sudo -E sh -c </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">patchelf --set-rpath /another_root/usr/lib {}</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>Now the musl executables should work, and those programs may be able to access the host glibc-system executables too.</p><div class="language-bash line-numbers-mode"><button class="copy"></button><span class="lang">bash</span><pre><code><span class="line"><span style="color:#676E95;"># both of these work!!!</span></span>
<span class="line"><span style="color:#676E95;"># First one may even correspond to musl linked executable!</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">/another_root/usr/bin/ls</span></span>
<span class="line"><span style="color:#A6ACCD;">ls</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;"># musl executable calling glibc-system executable, and it works!</span></span>
<span class="line"><span style="color:#A6ACCD;">/another_root/usr/bin/dash -c /usr/bin/ls</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>This means that you can easily add these executables in your <code>$PATH</code> without any modification to <code>$LD_LIBRARY_PATH</code> and other stuffs that could&#39;ve previously even break your system e.g. with version-mismatch if there were two glibc versions. They&#39;ll now work as expected (that easily).</p>`,20);function h(s,u,b,m,g,y){return l(),a("div",null,[e("h1",p,[t(o(s.$frontmatter.title)+" ",1),c]),d])}const w=n(i,[["render",h]]);export{D as __pageData,w as default};
