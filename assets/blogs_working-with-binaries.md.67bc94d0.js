import{_ as u,H as o,o as n,c as r,C as s,a as i,t,J as p,E as m,F as b,R as y,V as g,D as C,G as f}from"./chunks/framework.d1c50dd7.js";const A="/site/assets/cover.b0224843.jpg";const L=JSON.parse('{"title":"Working with Binaries","description":"Running system-incompatible binaries","frontmatter":{"title":"Working with Binaries","description":"Running system-incompatible binaries","created":"2022-09-26 12:00 AM","tags":["low-level"],"draft":true},"headers":[],"relativePath":"blogs/working-with-binaries.md","filePath":"blogs/working-with-binaries.md","lastUpdated":1687894822000}'),w={name:"blogs/working-with-binaries.md"},_={id:"frontmatter-title",tabindex:"-1"},D=s("a",{class:"header-anchor",href:"#frontmatter-title","aria-label":'Permalink to "{{ $frontmatter.title }}"'},"​",-1),k={style:{"font-size":"20px"}},v={style:{color:"gray","font-size":"14px"}},F={class:"tags"},x=g('<hr><p><img src="'+A+`" alt="Cover Image"></p><p>I really struggled first when I was introduced to cross-compilation in C. It was when I tried to compile a C as a library (.so/.dll) for exposing a few functionality to JVM/NodeJS in my keyboard-mouse-kt project.</p><p>It was really troublesome to see that cross-compilers don&#39;t exist in alpine repositories and only a few selected ones are on debian. So I literally made my own docker image with my own build of <a href="https://github.com/Animeshz/mainstream-cross-compilers" target="_blank" rel="noreferrer">cross-compilers</a>. It was fun! And I still refer to them.</p><p>I&#39;ve been tinkering with binaries ever since then, like for example <a href="https://www.youtube.com/watch?v=EJtUW2AklVs&amp;list=PLI_rLWXMqpSkAYfar0HRA7lykydwmRY_2&amp;index=2" target="_blank" rel="noreferrer">setuid to gain superuser without sudo</a> and stuffs like that.</p><p>And today I found something very interesting, and its not on exploitation, but could be something very useful for something like multiple-version package installation by putting them into directory of their own, see below.</p><h2 id="running-binaries-in-seperate-root-even-linked-against-musl-libc-in-glibc-environment" tabindex="-1">Running binaries in seperate root (even linked against musl libc in glibc environment) <a class="header-anchor" href="#running-binaries-in-seperate-root-even-linked-against-musl-libc-in-glibc-environment" aria-label="Permalink to &quot;Running binaries in seperate root (even linked against musl libc in glibc environment)&quot;">​</a></h2><h3 id="abstract" tabindex="-1">Abstract <a class="header-anchor" href="#abstract" aria-label="Permalink to &quot;Abstract&quot;">​</a></h3><p>For new ones, libc is something that exposes functionalities like <code>printf</code> and similar so that you can interface with the world outside the very basic primitives processor defines like add or subtract.</p><p>There are many libc implementations, in Windows there&#39;s one standard <code>msvcrt.dll</code> (generally referred to as MSVC), in Linux there are two implementations: glibc (33MB, from GNU) and musl (4MB, by Rich Felker). The other one is trying to replace the former which has legacy garbage.</p><blockquote><p>FunFact: MinGW (even though uses gnu-gcc compilers) links with msvcrt and not glibc.</p></blockquote><h3 id="let-s-go" tabindex="-1">Let&#39;s go <a class="header-anchor" href="#let-s-go" aria-label="Permalink to &quot;Let&#39;s go&quot;">​</a></h3><p>I&#39;ve recently tried to unify multiple package managers and had to deal with many edge-cases while trying to reduce the system modification while installation yet giving binary/fonts/config access to the user, there could&#39;ve been many ways, symlinking, bind-mounts, overlayfs/aufs, fusefs like the one bedrock-linux do, etc. Even though any of them would&#39;ve worked, there was one major problem, the packages from big repositories are made for libraries present in <code>/usr/lib</code> and against system libc/interpreter.</p><p>Once you have prepared a sepearte root (e.g. of musl based linux) say in <code>/another_root</code> (explained in <a href="/site/notes/linux/linux-random-stuffs.html#process-monitoring-usr-bin-time">Linux/RandomStuffs</a>), the way we execute binaries in seperate root is either by <code>chroot</code>ing, or by:</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">LD_LIBRARY_PATH</span><span style="color:#89DDFF;">=</span><span style="color:#C3E88D;">/another_root/usr/lib</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">/another_root/usr/lib/ld-musl-x86_64.so.1</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">/another_root/usr/bin/</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C3E88D;">binar</span><span style="color:#A6ACCD;">y</span><span style="color:#89DDFF;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Bla bla bla, too much to modify.</p><p>Fortunately there&#39;s <a href="https://github.com/NixOS/patchelf" target="_blank" rel="noreferrer">NixOS/patchelf</a> available which exactly modifies binaries search path and interpreter. So the following will replace all absolute path symlink, the libc interpreter, and the library search path for that particular executable.</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">fd</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">-tl</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">.</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">/another_root</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">|</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">xargs</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">-I</span><span style="color:#A6ACCD;">{} sudo sh -c &#39;lnk=$(readlink {} | grep &quot;^/&quot;) &amp;&amp; ln -sf /another_root$lnk {}&#39;</span></span>
<span class="line"><span style="color:#FFCB6B;">fd</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">-tx</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">.</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">/another_root/usr/bin</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">|</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">xargs</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">-I</span><span style="color:#A6ACCD;">{} sudo sh -c &#39;file {} | grep ELF &gt; /dev/null &amp;&amp; echo {}&#39; | xargs -I{} sudo -E sh -c &#39;ip=$(patchelf --print-interpreter {} 2&gt;/dev/null) &amp;&amp; patchelf --set-interpreter /another_root$ip {}&#39;</span></span>
<span class="line"><span style="color:#FFCB6B;">fd</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">-tx</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">.</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">/another_root/usr/bin</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">|</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">xargs</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">-I</span><span style="color:#A6ACCD;">{} sudo sh -c &#39;file {} | grep ELF &gt; /dev/null &amp;&amp; echo {}&#39; | xargs -I{} sudo -E sh -c &#39;patchelf --set-rpath /another_root/usr/lib {}&#39;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>Now the musl executables should work, and those programs may be able to access the host glibc-system executables too.</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;"># both of these work!!!</span></span>
<span class="line"><span style="color:#FFCB6B;">/usr/bin/ls</span></span>
<span class="line"><span style="color:#FFCB6B;">/another_root/usr/bin/ls</span><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;"># This one may even correspond to musl linked executable!</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;"># musl executable calling glibc-system executable, and it works too!</span></span>
<span class="line"><span style="color:#FFCB6B;">/another_root/usr/bin/dash</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">-c</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">/usr/bin/ls</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>This means that you can easily add these executables in your <code>$PATH</code> without any modification to <code>$LD_LIBRARY_PATH</code> and other stuffs that could&#39;ve previously even break your system e.g. with version-mismatch if there were two glibc versions. They&#39;ll now work as expected (that easily).</p>`,21);function B(e,E,I,$,T,R){const c=o("BlogMetadata"),d=o("ClientOnly"),h=o("MultiplexAd");return n(),r("div",null,[s("h1",_,[i(t(e.$frontmatter.title)+" ",1),D]),p(d,null,{default:m(()=>{var a,l;return[(((a=e.$frontmatter)==null?void 0:a.aside)??!0)&&(((l=e.$frontmatter)==null?void 0:l.showArticleMetadata)??!0)?(n(),C(c,{key:0,frontmatter:e.$frontmatter,wordCount:494},null,8,["frontmatter"])):f("",!0)]}),_:1}),s("p",k,t(e.$frontmatter.description),1),s("p",v,[i(t(e.$frontmatter.created)+" - ",1),s("span",F,[(n(!0),r(b,null,y(e.$frontmatter.tags,a=>(n(),r("span",null,"#"+t(a),1))),256))])]),x,p(h)])}const M=u(w,[["render",B]]);export{L as __pageData,M as default};
